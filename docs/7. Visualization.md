# Visualization

## Introduction

Pawpaw included limited visualization tools intended to help develop, test, and debug.

## Format Strings

Pawpaw's ``Ito`` has a well defined  ``.__format__`` that makes it possible to specify a format string for
an ``Ito`` object in [formatted string literals](https://docs.python.org/3/reference/lexical_analysis.html#f-strings) and when using ``str.format()``.
Two categories of formatting directives are available: Integer and String, each with its own vocabulary and modifiers.  Both formatting directives
can occur within a single f-string expression.

### Integer Expressions

An integer expression has the following form:

```
integer expression := directive[:[[fill]align][sign][width][grouping_option]]}
```

The *directive* field has one of the following values:

| Directive | Meaning | Example |
| :---:     |  ---    |   ---   |
| ``'%span'`` | Ito.span as tuple | '(1, 14)' |
| ``'%start'`` | Ito.start | '1' |
| ``'%stop'`` | Ito.stop | '14' |

The *fill*, *align*, *sign*, *width*, and *grouping_option* fields have identical form and behavior as Python's 
[Format Specification Mini-Language](https://docs.python.org/3/library/string.html?highlight=fill%20align%20sign%20width#format-specification-mini-language).
Conversely, the characters 'z', '#', '0' and fields *precision* and *type* are not supported.

#### Examples

```python
>>> from pawpaw import Ito
>>> i = Ito(' Hello, world! ', 1, -1, 'phrase')
>>> f'{i:%span}
'(1, 14)'
>>> f'{i:%start -> %stop}'
'1 -> 14'
>>> f'{i:%stop:~^10}
'~~~~14~~~~'
```

### String Expressions

While Pawpaw's Ito integer expressions are nearly identical to Python's, string expressions have many key differences.  A string expresssion has the form:

```
string expression := directive[!conversion][:[[fill]align][width[,abbr_suffix]]
```

The *directive* field has one of the following values:

| Directive | Meaning | Example |
| :---:     |  ---    |   ---   |
| ``'%string'`` | Ito.string | ' Hello, world! ' |
| ``'%desc'`` | Ito.start | 'phrase' |
| ``'%substr'`` | Ito.stop | 'Hello, world!' |
| ``'%value'`` | Ito.stop | 'Hello, world!' |

The *conversion* field has one of the following three values:

| Value | Meaning | Example |
| :---: |  ---    |   ---   |
| ``'a'`` | ascii | '\n' -> "'\\n'" |
| ``'r'`` | repr | '\n' -> '\n' |
| ``'s'`` | str (default) | '\n' -> "'\\n'" |

The *fill* field is a char used as needed to pad output to match the desired *minimum* width, and defaults to a single
space if omitted.  In max-width mode (see below), this field is ignored.

The *align* field has similar behavior to Python's, however, only three values are supported:

| Value | Meaning |
| :---: |   ---   |
| ``'<'`` | Left-aligns within available space (default) |
| ``'>'`` | Right-aligns within available space |
| ``'^'`` | Centers within available space |

The *width* and *abbr_suffix* fields are where Pawpaw significantly differs from Python's format string language.  The *width*
field can indicate either maximum or minimum width for the output value.  The meaning is inferred from the presence
or absence of the *abbr_suffix* field:

* present: *width* treated as max-width
* absent: *width* treated as min-width

Note that you can't use a digit as a value for *abbr_suffix*.  If you try to, it will be assumed to be part of the value for *width* instead.

Expressions for min-width behavior identically to Python format strings.  Namely, if the value is shorter than the indicated max-width, the fill
character is padded to the left, right, or both sides of the value (depending on *align*) until the desired width is reached.  If the desired
value is longer, no padding is added and the value is returned as is.

By contrast, for max-width behavior, values longer than *width* are truncated.  This is highly uself for large ``Ito`` trees, in which many nodes
will have long substring values.  By specifying a maximum width, output can be shortened to faciliate out visualization and interpretation.

When max-width is specified, the output value gets simultaneously truncated and appended with the value of *abbr_suffix* in order to fit
within the specified value for *width*.  For example:

```python
>>> f'{:&substr:4…}'
'Hel…'
```

### Examples:

```python
>>> f'{i:%string}
>>> f'{i:%span : %substr}
'(1, 14) : Hello, world!'
>>> f'{i:%string!r~^20}
```

## peduncle

The peduncle[^peduncle] module allows for quick visualization of 

Pawpaw's core funct is primarily intended Pawpaw is not primarily 

**string:**  
an ordered sequence of **n** characters; the *length* of a string is equivalent to **n**:

$$0 \leq n \equiv length$$

**substring:**  
an ordered sequence of **m** characters *contained in* or *equal to* a reference string of length **n**; may exist in more than one *location* within a string:

$$m \leq n$$

**proper substring:**  
 a substring of **m** characters that is *not equal to* a reference string of length **n**:

$$m < n$$
    
**segment:**  
 a *specific* substring of **m** characters identified by its *inclusive* **start** location, a zero-based index; the sum of **start** and **m** is equivalent to the *exclusive* **stop** location:

$$start + m ≡ stop$$

 as a result of this relationship, a segment can be uniquely identified using *any two* values from **start**, **stop**, or **m**; **stop** must be less than or equal to **n**:

 $$0 \leq start \leq stop \leq n$$
 
A *segment* is frequently identified by its *inclusive* **start** and *exclusive* **stop** locations within a reference string.  Two integers can identify a valid segment for a string of length **n** if they are:

1. ordered
2. between zero and **n** inclusive

.. sidebar:: Segment as a vector

 A segment can be thought of as a one dimensional vector having a location at ``start``, and a length of ``stop-start``.

A segment having a non-zero **start** value *-or-* a **stop** value less than **n** defines a *proper substring*.

It is possible for a segment to have identical **start** and **stop** values, in which case it defines an *empty substring* (i.e., zero length) at a *specific location*.

In Python, a ``str`` is immutable.  And because since substrings are themselves ``str`` objects, they too are immutable.  This attribute extends to segments, which because they define a substring, are also immutable.

.. admonition:: Key Concept

   Segments are immutable

Span
====

A segment can be represented in Python with a 2-tuple of ``int`` values.  Pawpaw offers a class named ``Span``[^span_name] for this purpose. ``Span`` is derived from Python's `NamedTuple <https://docs.python.org/3/library/collections.html?highlight=namedtuple#collections.namedtuple>`_, which results in a tuple-like object that:

- has fields accessible by attribute lookup
- is indexable and iterable
- requires no more memory than regular tuples
- has immutable elements.
 
Because they are tuples, ``Span`` objects are themselves immutable.  This ensures that immutable representation for segments within Pawpaw.

Creating a ``Span`` only requires a pair of ``int`` value for ``start`` and ``stop``:

```python
>>> Span(0, 3)
Span(start=0, stop=3)
```

[^peduncle] :  the stalk of a flower or an inflorescence
