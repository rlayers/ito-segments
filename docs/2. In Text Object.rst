===============
 In Text Object
===============

Introduction
============

A segment requires a reference string in order to fully describe a substring.  Likewise, a ``Span`` requires a reference ``str`` for context.  The segments module pairs a ``Span`` and ``str`` together as an *In Text Object*\ [#]_, which is implemented in the class ``Ito``.

Instantiation
=============

Creating from a ``str``
~~~~~~~~~~~~~~~~~~~~~~~

Instantiating an ``Ito`` against a reference ``str`` is straightforward:

>>> s = 'Hello, World!'
>>> Ito(s)
segments.Ito('Hello, World!', 0, 13, None)

The ``str`` value supplied to the constructor is accessible via a ``.string`` property.  The constructor features optional ``start`` and ``stop`` parameters, which are are *Python-style indices*.  The values for ``str``, ``start``, and ``stop`` are used to create a ``Span``, which is accessible via the ``.span`` property:

>>> i = Ito('abcd', 1, -1)
>>> i.span
Span(start=1, stop=3)

The ``start`` and ``stop`` values for the span are accessible via ``.start`` and ``.stop`` properties on *both* the ``Ito`` and ``Span``:

>>> i = Ito('abc')
>>> i.span == (i.start, i.stop)
True

``Ito`` also features a ``.descriptor`` property, which serves as a tag to describe the *type* of segment referred to.  An optional ``descriptor`` property is available in the constructor:

>>> s = 'John Doe'
>>> i1 = Ito(s, stop=4, descriptor='FN')
>>> i2 = Ito(s, 5, descriptor='LN')
>>> f'{i1.descriptor}: "{i1}";  {i2.descriptor}: "{i2}"'
'FN: "John"; LN: "Doe"'

The ``.string``, ``.start``, ``.stop``, and ``.span`` properties are all read-only and invariant.  On the ``.span`` property can be changed post-instantiation.  This is by design and ensures that the substring described by an ``Ito`` is an immutable object\ [#]_ in the segments module.  Trying to set any of these values results in an Error:

>>> i = Ito('abc')
>>> i.string = 'xyz'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Attribute Error: can't set attribute 'string'

.. admonition:: Key Concept

   ``Ito`` segments are immutable

Creating from another ``Ito``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A common task involves creating one substring from another.  This is easily performed by supplying an ``Ito`` as the first parameter, ``src``, to the constructor instead of a ``str``.  The ``start`` and ``stop`` parameters are *relative to ``Ito``.

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # substring 'abc'
>>> i2 = Ito(i1, 1, -1)  # indices relative to i1, not s
>>> print(i2, *i2.span)
b 2 3

Creating from substrings
~~~~~~~~~~~~~~~~~~~~~~~~

A common Python task involves creating or receiving substrings.  ``Ito`` provides a convenient ``classmethod`` called ``.from_substrings`` that, when supplied with a ``src`` of type ``str`` and a sequence of non-overlapping substrings, will generate a sequence of Ito objects:

>>> s = 'A B C'
>>> [*Ito.from_substrings(s, *s.split())]
[segments.Ito('A B C', 0, 1, None), segments.Ito('A B C', 2, 3, None), segments.Ito('A B C', 4, 5, None)]


Creating from substrings
~~~~~~~~~~~~~~~~~~~~~~~~

**TODO**


Creating from ``regex.Match``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**TODO**


Cloning
~~~~~~~

Clone versus ctor:

``.clone()`` preserves:

    * .value
    * .children
    * *type* of Ito (i.e., derived)

Prevervation of *type* is important if you have classes derived from ``Ito``:
The typing is important for derived classes:

>>> class DerivedIto(Ito):
...     def __init__(self, basis, start=None, stop=None, desc=None):
...         super().__init__(basis, start, stop, desc)
...
>>> i = DerivedIto('abc')
>>> c = i.clone()
>>> type(c).__name__
'DerivedIto'

Blah blah blah

This is supported via the static constructor ``.clone``

>>> s = ' abc '
>>> i = Ito(s, 1, -1, descriptor='original')
>>> i.clone(descriptor='duplicate')
segments.Ito(' abc ', 1, 4, 'duplicate')

Like the ``Ito`` constructor, the ``.clone`` method supports ``start`` and ``stop`` parameters that are *Python-style indices.*  This enables easy creation of *relative* clones:

>>> s = ' abc '
>>> i = Ito(s, descriptor='original')
>>> i.clone(1, -1, 'duplicate')  # indices relative to i, not str
segments.Ito(' abc ', 2, 3, 'duplicate')


Usage
=====

``str`` usage
~~~~~~~~~~~~~

__x__ support
~~~~~~~~~~~~~
** TODO **


``join`` method
~~~~~~~~~~~~~~~~~~
** TODO **


``value`` 
~~~~~~~~~
** TODO **


str equivalence methods
~~~~~~~~~~~~~~~~~~~~~~~
** TODO **


regex equivalence methods
~~~~~~~~~~~~~~~~~~~~~~~~~
** TODO **


``children`` 
============

An ``Ito`` is fully hierarchical through its ``.parent`` and ``.children`` properties.  This allows an ``Ito`` to both represent a segment and act as a node within a graph\ [#]_.

.. admonition:: Key Concept

   Given a set of rules that identify segment lineages, an ``Ito`` hierarchy can be used as topologically complete data collection for all discovered segments.
   
   The ``.desc`` property allows for users to define the *type* of segment an ``Ito`` refers to.  For example, a set of NLP rules might create segments of type *paragraph*, *sentence*, *word*, etc.  Conversely, rules for XML segmentation have segments named *element*, *attribute*, *key*, *value*, etc.

.. admonition:: Key Concept

   Segment relevance is determined by both a) the location of ``Ito`` within its hierarchy and b) the .desc for the ``Ito``
   

An ``Ito`` is not an arbitray data collection.  Rather, it defines segments wihtin text and can have ancestors, siblings, and decendants.  This results in several implicit assumptions:

* Children are contained in their parent: The ``.span`` for a child ``Ito`` is contained within the ``.span`` of its ``.parent``
* Non-overlapping siblings: An ``Ito`` does not overlap any other ``Ito`` objects that share the same ``.parent``
* Ordered siblings: Siblings are ordered within their parent by their ``.span.start``; because they are non-overlapping, the ``.span.stop`` for an ``Ito`` will always be less than or equal to the ``.span.start`` of the subsequent sibling


.. [#] The name "In Test Object" is historical, and dates back to earlier projects I developed.  I've chosen to keep this name because "Ito" makes for a short, convenient type name.

.. [#] In Python, strings are also immutable.

.. [#] Because a child ``Ito`` must be equal to or contained by a parent ``Ito``, this is a *tree* graph.
