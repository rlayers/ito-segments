===============
 In Text Object
===============

Introduction
============

A segment requires a reference string in order to fully describe a substring.  Likewise, a ``Span`` requires a reference ``str`` for context.  The segments module pairs a ``Span`` and ``str`` together as an *In Text Object*\ [#]_, which is implemented in the class ``Ito``.

Namespace
=========

``Ito`` is located as a root level object in the namespace ``segments``::

 >>> import segments
 >>> segments.Ito  # via import
 <class 'segments.ito.Ito'>
 >>> from segments import Ito 
 >>> Ito # via from
 <class 'segments.ito.Ito'>

Instantiation
=============

Creating from a ``str``
~~~~~~~~~~~~~~~~~~~~~~~

Instantiating an ``Ito`` against a reference ``str`` is straightforward:

>>> s = 'Hello, World!'
>>> Ito(s)
Ito('Hello, World!', 0, 13, None)

The ``str`` value supplied to the constructor is accessible via a ``.string`` property.  The constructor features optional ``start`` and ``stop`` parameters, which are are *Python-style indices*.  The values for ``str``, ``start``, and ``stop`` are used to create a ``Span``, which is accessible via the ``.span`` property:

>>> i = Ito('abcd', 1, -1)
>>> i.span
Span(start=1, stop=3)

The ``start`` and ``stop`` values for the span are accessible via ``.start`` and ``.stop`` properties on *both* the ``Ito`` and ``Span``:

>>> i = Ito('abc')
>>> i.span == (i.start, i.stop)
True

``Ito`` also features a ``.desc`` property\ [#]_, which serves as a tag for describing the *type* of segment referred to.  An optional ``desc`` parameter is the fourth and final one in the constructor:

>>> s = 'John Doe'
>>> i1 = Ito(s, stop=4, desc='FN')
>>> i2 = Ito(s, 5, desc='LN')
>>> f'{i1.desc}: "{i1}";  {i2.desc}: "{i2}"'
'FN: "John"; LN: "Doe"'

The ``.string``, ``.start``, ``.stop``, and ``.span`` properties are all read-only and invariant.  On the ``.span`` property can be changed post-instantiation.  This is by design and ensures that the substring described by an ``Ito`` is an immutable object\ [#]_ in the segments module.  Trying to set any of these values results in an Error:

>>> i = Ito('abc')
>>> i.string = 'xyz'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Attribute Error: can't set attribute 'string'

.. admonition:: Key Concept

   ``Ito`` segments are immutable

Creating from another ``Ito``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Frequently, you will want to create one substring based on another.  This can be achieved by supplying an ``Ito`` as the first parameter to the constructor instead of a ``str``.  The ``start`` and ``stop`` parameters are *relative to what is passed as the first parameter:

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # 'abc' : indices relative to s
>>> i2 = Ito(i1, 1, -1)  #   'b' : indices relative to i1, not s
>>> print(i2, *i2.span)
b 2 3

Creating from substrings
~~~~~~~~~~~~~~~~~~~~~~~~

Creating and/or receiving substrings is a common Python task.  ``Ito`` provides a convenient ``classmethod`` named ``.from_substrings`` that, when supplied with a ``src`` of type ``str`` and a sequence of non-overlapping substrings, will generate a sequence of Ito objects:

>>> s = 'A B C'
>>> [*Ito.from_substrings(s, *s.split())]  # Creates 3 strs: 'A', 'B', and 'C'
[Ito('A B C', 0, 1, None), Ito('A B C', 2, 3, None), Ito('A B C', 4, 5, None)]

Like the ``Ito`` constructor, this method allows passing either a ``str`` or an ``Ito`` as the first parameter.  When an ``Ito`` is passed, the substrings must be present in the substring described by the ``Ito``.




Creating from substrings
~~~~~~~~~~~~~~~~~~~~~~~~

**TODO**


Creating from ``regex.Match``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**TODO**


Cloning
~~~~~~~

Clone versus ctor:

``.clone()`` preserves:

    * .value
    * .children
    * *type* of Ito (i.e., derived)

Prevervation of *type* is important if you have classes derived from ``Ito``:
The typing is important for derived classes:

>>> class DerivedIto(Ito):
...     def __init__(self, basis, start=None, stop=None, desc=None):
...         super().__init__(basis, start, stop, desc)
...
>>> i = DerivedIto('abc')
>>> c = i.clone()
>>> type(c).__name__
'DerivedIto'

Blah blah blah

This is supported via the static constructor ``.clone``

>>> s = ' abc '
>>> i = Ito(s, 1, -1, 'original')
>>> i.clone(desc='duplicate')
Ito(' abc ', 1, 4, 'duplicate')

Like the ``Ito`` constructor, the ``.clone`` method supports ``start`` and ``stop`` parameters that are *Python-style indices.*  This enables easy creation of *relative* clones:

>>> s = ' abc '
>>> i = Ito(s, desc='original')
>>> i.clone(1, -1, 'duplicate')  # indices relative to i, not str
Ito(' abc ', 2, 3, 'duplicate')


Usage
=====

``str`` usage
~~~~~~~~~~~~~

There are many ways to substring referred to by an ``Ito``\ ::

 i.__str__()  # direct call to __str__
 f'{i}'       # indirect call to __str__
 i[:]         # list comprehension of chars

The default behavior of the ``.value()`` is to make a subcall to ``.__str__()``.  However, the intent of ``.value()`` is to provide an alternative representation of the the underlying substring, and it will be frequently overriden.  Note ``.value()`` is type hinted to return ``typing.Any``, so there is not even a guarantee that it will return a ``str``.

__x__ support
~~~~~~~~~~~~~
** TODO **


``join`` method
~~~~~~~~~~~~~~~~~~
** TODO **


``value`` 
~~~~~~~~~
** TODO **


str equivalence methods
~~~~~~~~~~~~~~~~~~~~~~~
** TODO **


regex equivalence methods
~~~~~~~~~~~~~~~~~~~~~~~~~
** TODO **


``children`` 
============

An ``Ito`` is fully hierarchical through its ``.parent`` and ``.children`` properties.  This allows an ``Ito`` to both represent a segment and act as a node within a graph\ [#]_.

.. admonition:: Key Concept

   Given a set of rules that identify segment lineages, an ``Ito`` hierarchy can be used as topologically complete data collection for all discovered segments.
   
   The ``.desc`` property allows for users to define the *type* of segment an ``Ito`` refers to.  For example, a set of NLP rules might create segments of type *paragraph*, *sentence*, *word*, etc.  Conversely, rules for XML segmentation have segments named *element*, *attribute*, *key*, *value*, etc.

.. admonition:: Key Concept

   Segment relevance is determined by both a) the location of ``Ito`` within its hierarchy and b) the .desc for the ``Ito``
   

An ``Ito`` is not an arbitray data collection.  Rather, it defines segments wihtin text and can have ancestors, siblings, and decendants.  This results in several implicit assumptions:

* Children are contained in their parent: The ``.span`` for a child ``Ito`` is contained within the ``.span`` of its ``.parent``
* Non-overlapping siblings: An ``Ito`` does not overlap any other ``Ito`` objects that share the same ``.parent``
* Ordered siblings: Siblings are ordered within their parent by their ``.span.start``; because they are non-overlapping, the ``.span.stop`` for an ``Ito`` will always be less than or equal to the ``.span.start`` of the subsequent sibling


.. [#] The name "In Test Object" is historical, and dates back to earlier projects I developed.  I've chosen to keep this name because "Ito" makes for a short, convenient type name.

.. [#] In earlier versions of the framework, this was named ``descriptor``.  Its usage, however, is frequent.  A ten-character long identifier, although perhaps more descriptive of intent, winds up for less readable and more verbose code.

.. [#] In Python, strings are also immutable.

.. [#] Because a child ``Ito`` must be equal to or contained by a parent ``Ito``, this is a *tree* graph.
