===============
 In Text Object
===============

Introduction
============

In order to fully describe a substring, a segment requires a reference string.  In other words, both a ``Span`` and ``str`` are required, which is represented in Pawpaw via the *In Text Object*\ [#]_, implemented as class ``Ito``.

Namespace
=========

``Ito`` is as a root level object in the namespace ``pawpaw``::

 >>> from pawpaw import Ito

Instantiation
=============

Creating from a ``str``
~~~~~~~~~~~~~~~~~~~~~~~

Instantiating an ``Ito`` against a reference ``str`` is straightforward:

>>> s = 'Hello, World!'
>>> Ito(s)
Ito('Hello, World!', 0, 13, None)

The ``str`` value supplied to the constructor is accessible via a ``.string`` property.  The constructor features optional ``start`` and ``stop`` parameters, which are are *Python-style indices*.  The values for ``str``, ``start``, and ``stop`` are used to create a ``Span``, which is accessible via the ``.span`` property:

>>> i = Ito('abcd', 1, -1)
>>> i.span
Span(start=1, stop=3)

Having separate ``start`` and ``stop`` parameters is more idiomatic with Python than using a single, ``Span`` parameter.  However, given a span you can easily supply these values via unpacking:

>>> from pawpaw import Span
>>> span = Span(1, 3)
>>> i = Ito('abcd', *span)
>>> i
Ito('abcd', 1, 3, None)

The ``start`` and ``stop`` values for the span are accessible via ``.start`` and ``.stop`` properties on *both* the ``Ito`` and ``Span``:

>>> i = Ito('abc')
>>> i.span == (i.start, i.stop)
True

``Ito`` also features a ``.desc`` property\ [#]_, which serves as a tag for describing the *type* of segment referred to.  An optional ``desc`` is the fourth and final parameter to the constructor:

>>> s = 'John Doe'
>>> i1 = Ito(s, stop=4, desc='FN')
>>> i2 = Ito(s, 5, desc='LN')
>>> f'{i1.desc}: "{i1}";  {i2.desc}: "{i2}"'
'FN: "John"; LN: "Doe"'

The ``.string``, ``.start``, ``.stop``, and ``.span`` properties are all read-only and invariant.  Only the ``.desc`` property can be changed post-instantiation.  This is by design and ensures that substrings described by itos are immutable\ [#]_ in Pawpaw.  Trying to set any of these values results in an Error:

>>> i = Ito('abc')
>>> i.string = 'xyz'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Attribute Error: can't set attribute 'string'

.. admonition:: Key Concept

   ``Ito`` strings and spans are immutable

Creating from another ``Ito``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Frequently, you'll want to create one substring from another.  This can be achieved by supplying an ``Ito`` as the first parameter to the constructor instead of a ``str``.  The ``start`` and ``stop`` parameters are *relative to the first parameter*\ [#]_:

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # str basis; skip first & last chars of str s
>>> i2 = Ito(i1, 1, -1)  # Ito basis; skip first and last chars of Ito i1
>>> str(i1), str(i2)
('abc', 'b')

Creating from substrings
~~~~~~~~~~~~~~~~~~~~~~~~

Given a sequence of substrings, you can create an ``Ito`` sequence using the static ``.from_substrings`` method.  When supplied with a ``src`` of type ``str`` or ``Ito`` and one or more non-overlapping substrings, this method generates a sequence of ``Ito`` objects:

>>> s = 'A B C'
>>> [*Ito.from_substrings(s, *s.split())]
[Ito('A B C', 0, 1, None), Ito('A B C', 2, 3, None), Ito('A B C', 4, 5, None)]


Creating from ``regex.Match``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**TODO**


Cloning
~~~~~~~

Clone versus ctor:

``.clone()`` preserves:

    * .value
    * .children
    * *type* of Ito (i.e., derived)

Preservation of *type* is important if you have classes derived from ``Ito``:
The typing is important for derived classes:

>>> class DerivedIto(Ito):
...     def __init__(self, basis, start=None, stop=None, desc=None):
...         super().__init__(basis, start, stop, desc)
...
>>> i = DerivedIto('abc')
>>> c = i.clone()
>>> type(c).__name__
'DerivedIto'

Blah blah blah

This is supported via the static constructor ``.clone``

>>> s = ' abc '
>>> i = Ito(s, 1, -1, 'original')
>>> i.clone(desc='duplicate')
Ito(' abc ', 1, 4, 'duplicate')

Like the ``Ito`` constructor, the ``.clone`` method supports ``start`` and ``stop`` parameters that are *Python-style indices.*  This enables easy creation of *relative* clones:

>>> s = ' abc '
>>> i = Ito(s, desc='original')
>>> i.clone(1, -1, 'duplicate')  # indices relative to i, not str
Ito(' abc ', 2, 3, 'duplicate')


Usage
=====

``str`` usage
~~~~~~~~~~~~~

There are many ways to access the substring referred to by an ``Ito``\ ::

 i.__str__()  # direct call to .__str__
 str(i)       # indirect
 f'{i}'       # indirect
 
``.value()``
~~~~~~~~~~~~

The default behavior of the ``.value()`` is to make a subcall to ``.__str__()``.  However, the intent of ``.value()`` is to provide a interpreted value for the underlying substring, and it can be easily overriden.  For example, given this class:

::

 class IntIto(Ito)
     def value(self) -> Typing.Any:
         return int(str(self))

You could use it as follows:

>>> s = '1 2 3 4'
>>> itos = [*IntIto.from_substrings(s, *s.split())]
>>> [i.value() for i in itos]  # resolve to ints
[1, 2, 3]

``Ito`` provides a .value_func property accessors to allow for easier run-time assignment of a value method without relying on strict inheritance:

::

 >>> s = '1'
 >>> i = Ito(s)
 >>> i.value()
 '1'
 >>> i.value_func = lambda ito: int(str(ito))
 >>> i.value()
 1
 >>> i.value_func = None  # resets to default behavior
 >>> i.value()
 '1'

__x__ support
~~~~~~~~~~~~~
** TODO **


``join`` method
~~~~~~~~~~~~~~~~~~
** TODO **


equivalence methods
~~~~~~~~~~~~~~~~~~~

Guidelines

* Non-modifying: don't affect the ``Ito`` used to call them
* No str creation, e.g., ``str.join`` results in a new string, whereas ``str.split`` results in substrings only
* Returns: same type of non-str return values, ``Ito`` for str return values


str equivalence methods
""""""""""
To utilize the substring identified by an ``Ito`` requires first calling the ``.__str__()`` method.  However, this introduces an inefficiency - namely, a new string must be allocated and initialized in memory.  This can be avoided if the target method allows passing start and stop indices.  For example, the ``str`` method ``.find`` has start and end parameters, which can be leverage to avoid creating a substring::

>>> s = ' abc '
>>> i = Ito(s, 1, -1)
>>> str(i).find('b')  # Inefficient
1
>>> i.string.find('b', i.start, i.stop)  # Better
2

Although more efficient, the second approach is not desirable because a) it requires you to remember to pass in the indices and b) returns an offset from the start of the string, rather than the start of the substring.  Fortunately, ``Ito`` features built-in equivalence methods for all non-modifying ``str`` methods.  The methods:

* have the same name as their ``str`` counterpart, prefixed with ``str_``
* have identical parameters
* have return values that:

  * are identical if the ``str`` counterpart method returns a non-``str``
  * are ``Ito`` when the ``str`` counterpart method returns a ``str``
  
For example:

>>> i.str_find('b')
1

This method behaves as if you called ``find`` against the underlying substring, with a return value offset from the start of the substring, rather than the basis.


regex equivalence methods
""""""""""
** TODO **


``.children`` 
============

An ``Ito`` is fully hierarchical through its ``.parent`` and ``.children`` properties.  This allows an ``Ito`` to both represent a segment and act as a node within a graph\ [#]_.

.. admonition:: Key Concept

   Given a set of rules that identify segment lineages, an ``Ito`` hierarchy can be used as topologically complete data collection for all discovered segments.
   
   The ``.desc`` property allows for users to define the *type* of segment an ``Ito`` refers to.  For example, a set of NLP rules might create segments of type *paragraph*, *sentence*, *word*, etc.  Conversely, rules for XML segmentation have segments named *element*, *attribute*, *key*, *value*, etc.

.. admonition:: Key Concept

   Segment relevance is determined by both a) the location of ``Ito`` within its hierarchy and b) the .desc for the ``Ito``

An ``Ito`` is not an arbitrary data collection.  Rather, it defines segments within text and can have ancestors, siblings, and descendants.  This results in several implicit assumptions:

* Children are contained in their parent: The ``.span`` for a child ``Ito`` is contained within the ``.span`` of its ``.parent``
* Non-overlapping siblings: An ``Ito`` does not overlap any other ``Ito`` objects that share the same ``.parent``
* Ordered siblings: Siblings are ordered within their parent by their ``.span.start``; because they are non-overlapping, the ``.span.stop`` for an ``Ito`` will always be less than or equal to the ``.span.start`` of the subsequent sibling

----

.. [#] The name "In Test Object" is historical, and dates back to earlier projects I developed.  I've chosen to keep this name because "Ito" makes for a short, convenient type name!

.. [#] In earlier versions of the framework, this was named ``descriptor``.  Its usage, however, is frequent, and a ten-character long identifier makes for more verbose and less readable code.

.. [#] In Python, strings are also immutable.

.. [#] This is why the first parameter is named ``src`` and not ``string`` â€” it allows for *multiple* types to be used as the source for your substring

.. [#] Because a child ``Ito`` must be equal to or contained by a parent ``Ito``, this is a *tree* graph.
