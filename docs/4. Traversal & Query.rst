=================
Traversal & Query
=================

Introduction
============
Pawpaw's ``Ito`` class features recursive storage of descendants to arbitrary depth, which allows it to
be used as a hierarchical data store.  Traversal down to child nodes is possible through the the
``.children`` property, while traversal upwards can be accomplished through the ``.parent`` property:

>>> from pawpaw import Ito
>>> s = 'the quick brown fox'
>>> re = regex.compile(r'(?P<word>(?P<char>\w)+\W*)*')
>>> i = Ito.from_match(re.fullmatch(s))
>>> last_child = i.children[-1]  # traverse down to child
>>> str(last_child)  
'fox'
>>> str(last_child.parent)  # traverse up to parent
'the quick brown fox'

Pawpaw's ``Ito`` also allows you to traverse all descendants in at tree from a given node:

>>> print('|'.join(str(d) for d in i.walk_descendants()))
the|t|h|e|quick|q|u|i|c|k|brown|b|r|o|w|n|fox|f|o|x

Manually traversing an ``Ito`` the hierarchy is practical for small collections.  Larger collections,
by contrast, can benefit from Pawpaw *plumule* queries.  Plumule is similar in syntax to
`XPath <https://www.w3.org/TR/xpath/>` in syntax and usage.  For example:

>>> plumule_xpr = '*{*[s:o]}'  # words containing char 'o'
>>> print([str(w) for w in i.find_all(plumule_xpr)])
['brown', 'fox']

Because Plumule queries are strings, they can be persisted and used against multiple trees.  Plumule
queries are interpreted by the Pawpaw *radicle* query engine, which even allows you to pre-compile
them for faster performance:

>>> query = pawpaw.query.compile(plumule_xpr)
>>> print([str(w) for w in query.find_all(i)])
['brown', 'fox']

Plumule Syntax
==============

A Plumule query allows you to query for arbitrary nodes in an ``Ito`` Tree.  A query consists
of one or more *phrases* separated by fore-slash characters::

 query := phrase [/ phrase] [/ phrase] ...

Phrases
-------
A phrase consists of an *axis* along with an optional *filters* and *subqueries* parts::

phrase := axis [filters] [subqueries]

Axis
----

An axis consists of an optional *order operator*, a required *axis identifier*, and an optional *self option*: ::

 axis := [order_operator] axis_identifier [self_option]

A Plumule axis defines a traversal step.  For example, the axis identifier ``*`` indicates that traversal
should proceed to the children of the current node(s).  For a given node, an axis may yield zero,
one, or more nodes, the order of which will always be from nearest to farthest from the current node.

.. admonition:: Key Concept

   An axis always returns nodes ordered *nearest* to *farthest* from the current node(s), unless reversed.

The order of nodes can be reversed by using a minus character (-) for the order operator.  A plus
character (+) indicates nearest-to-furthest ordering, and is the assumed default when the
order operator is not supplied.

In some cases, it may be useful to return the current node as part traversal step.  For example,
the axis operator ``..`` indicates traversal to the parent node, however, if the current node is
a root, then there is no parent to traverse to.  The self option can be used to ensure that a
traversal step will always return something.  Two possible values are allows:

Self Option Values
^^^^^^^^^^^^^^^^^^

======  ====================================================
Value   Description
======  ====================================================
``!``   Returns current node only if traversal step is empty
------  ----------------------------------------------------
``!!``  Returns current node plus any traversal step nodes
======  ====================================================

If a self option is supplied, the current node will always be returned first, unless
the axis is reversed with the '-' operator.

Axis Identifiers
^^^^^^^^^^^^^^^^

+------------+----------------+------------------------------------------------------------------------+
| Identifier | Meaning        | Description                                                            |
+============+================+========================================================================+
| ``....``   | root           | Furthest ancestor of the current node that has no ancestors itself     |
+------------+----------------+------------------------------------------------------------------------+
| ``...``    | ancestors      | All ancestors of the current node beginning with the parent            |
|            |                | and ending with the root                                               |
+------------+----------------+------------------------------------------------------------------------+
| ``..``     | parent         | Nearest ancestor of the current node                                   |
+------------+----------------+------------------------------------------------------------------------+
| ``.``      | self           | Reflection of the current node                                         |
+------------+----------------+------------------------------------------------------------------------+
| ``*``      | children       | Children of the current node                                           |
+------------+----------------+------------------------------------------------------------------------+
| ``**``     | descendants    | All descendants of the current node, starting with the children and    |
|            |                | ending with leaves                                                     |
+------------+----------------+------------------------------------------------------------------------+
| ``***``    | leaves         | Descendants of the current node that have no descendants themselves    |
+------------+----------------+------------------------------------------------------------------------+
| ``<<<``    | preceeding     | Nodes that are *before* the current node, *includes* prior siblings    |
|            |                | and *excludes* ancestors & descendants                                 |
+------------+----------------+------------------------------------------------------------------------+
| ``<<``     | prior siblings | Nodes *before* the current node that have the same parent              |
+------------+----------------+------------------------------------------------------------------------+
| ``<``      | prior sibling  | The nearest node *before* the current node that has the same parent    |
+------------+----------------+------------------------------------------------------------------------+
| ``>``      | next sibling   |  The nearest node *after* the current node that has the same parent    |
+------------+----------------+------------------------------------------------------------------------+
| ``>>``     | next siblings  |  Nodes *after* the current node that have the same parent              |
+------------+----------------+------------------------------------------------------------------------+
| ``>>>``    | following      | Nodes that are *after* the current node, *includes* prior siblings     |
|            |                | and *excludes* ancestors & descendants                                 |
+------------+----------------+------------------------------------------------------------------------+

Examples
^^^^^^^^

::

 '*'    # all children; equivalent to iter(i.children)
 '*/*'  # all grandchildren; equivalent to iter(gc for c in i.children for gc in c.children)
 '../*' # all siblings and self: equivalent to i.parent.children
 '>>/*' # children of all successive siblings

Filters
-------

A phrase filters expression defines what A filter only allows nodes matching a given criteria to pass through,
and conists of one or more *filter* expressions separated by logical operators.  Parentheses may be used
to group filter expressions when you need to override the default operator precedance:

 filters := [not_operator] filter [ combining_operator [not_operator] filter ]...

Operators
^^^^^^^^^

The not operator consists of the tilde character ('~'):

  not_operator := '~'

A combining operator consists of either a '&', '^', or '|' character:

 combining_operator := '&, '^', or '|'
 
The operators are listed below in order of precedence:

+-----------+------------+----------+
| Operator  | Combining  | Meaning  |
+===========+============+==========+
|  ``~``    |            |   NOT    |
+-----------+------------+----------+
|  ``&``    | ✓          |   AND    |
+-----------+------------+----------+
|  ``^``    | ✓          |   XOR    |
+-----------+------------+----------+
|  ``|``    | ✓          |   OR     |
+-----------+------------+----------+

Filter
^^^^^^

A filter consists key-value pair, surrounded by square brackets.  You can prefix a key with the not operator ('~'), which has the same effect as if it occurs immediately to the left of the opening bracket.

 filter := '[' [NOT] key ':' value ']'

The filter key conists of a string that indicates what filtering action to perform on the current axis nodes.  The filter value
provides additional data to the filtering action.  Allowable values for keys and values are as follows:

+---------------------+------------------+------------------------------------------------------------------------+------------------+
| Key                 | Alt Keys(s)      | Meaning                                                                | Example(s)       |
+=====================+==================+========================================================================+==================+
| ``desc``            | ``d``            | One or more ``str`` values used to match againss ``.desc`` of axis;    | ::               |
|                     |                  | values must be separated with commas, literal commas must be escaped   |                  |
|                     |                  |                                                                        |  [d:number]      |
|                     |                  |                                                                        |  [d:word,char]   |
+---------------------+------------------+------------------------------------------------------------------------+------------------+
| ``string``          | ``s``            | A ``str`` used to match against ``.__str__()`` of axis                 | ::               |
|                     |                  |                                                                        |                  |
|                     |                  |                                                                        |  [s:foo]         |
|                     |                  |                                                                        |  [s:foo,goo]     |
+---------------------+------------------+------------------------------------------------------------------------+------------------+
| ``string-casefold`` | ``scf``, ``lcs`` | Like ``s``, with ``.casefold()`` applied to supplied value *and*       | ::               |
|                     |                  | value *and* ``.__str__()`` of axis prior to compare                    |                  |
|                     |                  |                                                                        |  [scf:FoO,GoO]   |
+---------------------+------------------+------------------------------------------------------------------------+------------------+
| ``index``           | ``v``            | One or more tuples consisting of a *start* and optional *stop* ``int`` | ::               |
|                     |                  | values used to match against the enumeration index(ices) of the axis;  |                  |
|                     |                  | *start* and *stop* must be separated with hyphens, tuples must be      |  [i:1]           |
|                     |                  | separated with commas                                                  |  [i:2,3,4]       |
|                     |                  |                                                                        |  [i:2-3]         |
|                     |                  |                                                                        |  [i:2,5-7]       |
+---------------------+------------------+------------------------------------------------------------------------+------------------+
| ``predicate``       | ``p``            | Key for filter function used to match against axis                     | ::               |
|                     |                  | A ``str`` used as a key to entry in dictionary of type:                |                  |
|                     |                  |                                                                        |   [p:key1]       |
|                     |                  |   typing.Dict[str, typing.Callable[[int, Ito], bool]                   |   [p:key1,key2]  |
|                     |                  |                                                                        |                  |
|                     |                  | The value retrieved from the ``dict`` use used as a filter against     |                  |
|                     |                  | the axis                                                               |                  |
+---------------------+------------------+------------------------------------------------------------------------+------------------+
| ``value``           | ``v``            | A ``str`` used as a key to entry in dictionary of type::               | ::               |
|                     |                  |                                                                        |                  |
|                     |                  |                                                                        |   [p:key]        |
|                     |                  |   typing.Dict[str, typing.Any]                                         |   [p:key1, key2] |
|                     |                  |                                                                        |                  |
|                     |                  | The value retrieved from the ``dict`` is used to match against the     |                  |
|                     |                  | ``.value()`` of the axis                                               |                  |
+---------------------+------------------+------------------------------------------------------------------------+------------------+

Parentheses are allowed to perform logical grouping::


Examples
^^^^^^^^

::

 '*[d:word,number]'  # all children having descriptor equal to 'word' or 'number'
 '**[~d:word] | ([d:word] & [s:ten])'  # all descedndants with descriptor not 'word', or with descriptor 'word and substr 'ten'

TIPS & TRICKS
=============

Q: How can I 'OR' together a filter and subquery?

A: Operators are not supported between the filter and subquery components of a query phrase.  However, you can achieve the same result by moving the filter to a subquery:

[my_filter]{my_subquery}  ->  {./[my_filter]} | {my_subquery}


.. [#] The name "In Test Object" is historical, and dates back to earlier projects I developed.  I've chosen to keep this name because "Ito" makes for a short, convenient type name.

.. [#] In Python, strings are also immutable.

.. [#] Because a child ``Ito`` must be equal to or contained by a parent ``Ito``, this is a *tree* graph.
