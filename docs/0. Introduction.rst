============
Introduction
============

Jumping Right In : *What Pawpaw can do for you*
=================================================

Say you have some text::

>>> s = 'nine 9 ten 10 eleven 11 TWELVE 12 thirteen 13'

and you wish to perform an nlp-like segmentation on phrases, words, numbers, and so forth.  Given
the regular expression:

>>> re = regex.compile(r'(?P<root>(?P<phrase>(?P<word>(?P<char>\w)+) (?P<number>(?P<digit>\d)+)\s*)+)')

You can use **pawpaw** as follows:

>>> root = next(Ito.from_re(re, s))



With just one line of code, you now have a fully hierarchical, tree\ [#]_ of phrases, words, chars,
numbers, and digits.  This tree can be traversed, and even searched using a powerful XPATH-like
structured query language:

>>> print(*root.find_all('**[d:digit]'), sep=', ')  # print all digits
9, 1, 0, 1, 1, 1, 2, 1, 3
>>> print(*root.find_all('**[d:number]{</*[s:i]}'), sep=',')  # print numbers having leter 'i' in their names
9, 13

Dive a Bit Deeper: *Introducing* ``Ito``
========================================

>>> from pawpaw import Ito
>>> s = 'x Hello, world! x'
>>> i = Ito(s, 2, -2)
>>> print(i)
Hello, world!

The class ``Ito``, short for *In Text Object*, is a high performance, indexed substring. Creating
an ``Ito`` does *not* create a new string.  Rather, an ``Ito`` maintains a reference to a basis
string, along with start and stop indexes:

>>> i
Ito('x Hello, world! x', 2, 15, None)

Because ``Ito`` only maintains a reference to its basis string, its memory requirements are low:

>>> import sys
>>> sys.getsizeof(s), sys.getsizeof(i)
(66, 48)
>> s2 = s * 4096  # a big str
>>> sys.getsizeof(s2), sys.getsizeof(Ito(s2))
(69681, 48)

Index Access
============

Like a regular Python ``str``, you access the character data in an ``Ito`` via ``int`` or ``slice`` indexers\ [#]_\ .  Indexing an ``Ito`` is always *relative to itself*, not the basis string:

>>> str(i[0])    # int accessor
H
>>> str(i[-1])   # int accessor
!
>>> str(i[:5])   # slice accessor
Hello
>>> str(i[-6:])  # slice accessor
world!
  
Index access on a ``str`` returns another ``str``.  Likewise, index access on an ``Ito`` returns another ``Ito``:

>>> i[-6:]
Ito(Hello, world!', 7, 13, None)

Note that index access allows ``Ito`` enumeration:

>>> for idx, ito in enumerate(i[:5]):
...     print(idx, ito):
...
0: H
1: e
2: l
3: l
4: o

Relative index access allows for clear, easy to use code:

>>> j = i[-6:]   # new Ito based on the last 6 characters of the previous Ito
>>> str(j[0:3])  # print first three characters of the new Ito

``Ito`` constructors allow for using either a ``str`` or an ``Ito`` as the basis parameter, ``src``.  The subsequent ``start`` and ``stop`` parameters are always *relative to ``src``*, with the original source string carried through and all indexing book-keeping handled automatically:

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # str basis; skip first & last chars of str s
>>> i2 = Ito(i1, 1, -1)  # Ito basis; skip first and last chars of Ito i1
>>> str(i1), str(i2)
('abc', 'b')

Descriptor
==========
``Ito`` features a ``.desc`` property that can be used for tagging.  Values for ``.desc`` can be specified as the final constructor property, or post-instantition via a property of the same name::

 >>> i = Ito('abc', desc='something useful')
 >>> i.desc
 'something useful'
 >>> i.desc = 'something different'
 >>> i.desc
 'something different'
 
 The ``.desc`` property facilitates search and retrieval of ``Ito`` collections.
 
Tree Data Store
===============

``Ito`` supports nested storage of child ``Ito`` instances via the ``.children`` property.  Nodes can be added via the ``.add`` method in arbitrary order.  They are always stored in sorted order:

>>> s = 'ABC 123'
>>> root = Ito(s)
>>> root.children.add(root[-3:], root[:3])
>>> [str(c) for c in root.children]
['ABC', '123']

The ``.children`` collection is not an arbitrary data store.  Nodes added to it must meet the following criteria:

* An instance (or sublass) of ``Ito``
* Have the same reference ``str`` as the parent
* Not overlap any existing child nodes
* Be non-empty

Child nodes have their own ``.children` collections, and so on.  In other words, ``Ito`` and its descendants form are hierarchical and from a tree graph.  This quality  is used for many key features of ``pawpaw``", such as:

* Storage and organization of substring data
* Hiearchical segmentation processing
* Traversal of substring collections
* Structured search and query

Aborform
========

Pawpaw makes it easy to create to create trees.  As seen in the introduction above, a fully formed tree of arbitrary depth can be formed using a single regular expression.  Creating large regular expressions, however, can sometimes be unwieldy.  Pawpaw's ``.aborform`` namespace contains wide variety of tools to help you quicly build trees using pipelining.  For example, the same tree shown in the Introduction can be created in chained, piecemeal fashion as follows::

>>> s = 'nine 9 ten 10 eleven 11 TWELVE 12 thirteen 13'
>>>
>>> root = Ito(s, desc='root')
>>>
>>> phrases = Split(regex.compile('(?<=\d )'), desc='Phrase')
>>>
>>> wrds_nums = Extract(regex.compile(r'(?P<word>[a-z]+) (?P<number>\d+)'))
>>> phrases.itor_children = wrds_nums
>>>
>>> chrs_digs = Extract(regex.compile(r'(?P<char>[a-z])+|(?P<digit>\d)+'))
>>> wrds_nums.itor_children = chrs_digs

----

.. [#] A tree is an undirected graph in which any two vertices are connected by exactly one path.  An ``Ito`` is technically a *rooted tree*, where the root is the ``Ito`` and the branches and leaves its descendants.

.. [#] Slices with step values other than 1 (or ``None``) are not supported because the resulting sequences of characters will typically *not* be valid substrings.  For example, ``'abc[::-1]`` results in the reversed string ``cba``, which doesn't align with the starting ``str``.
