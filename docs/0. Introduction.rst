=====================
Segments Introduction
=====================

Jumping Right In: Introducing the ``Ito``
=========================================

>>> from segments import Ito
>>> s = 'x Hello, world! x'
>>> i = Ito(s, 2, -2)
>>> print(i)
Hello, world!

The class ``Ito``, short for *In Text Object*, is a high performance, indexed substring. Creating
an ``Ito`` does *not* create a new string.  Rather, an ``Ito`` maintains a reference to a basis
string, along with start and stop indexes:

>>> i
Ito('Hello, world!', 2, 15, None)

Because ``Ito`` only maintains a reference to its basis string, its memory requirements are low:

>>> import sys
>>> sys.getsizeof(s), sys.getsizeof(i)
(66, 48)
>> s2 = s * 4096  # a big str
>>> sys.getsizeof(s2), sys.getsizeof(Ito(s2))
(69681, 48)

Index Access
============

Like a regular Python ``str``, you access the character data in an ``Ito`` via ``int`` or ``slice`` indexers\ [#]_\ .  Indexing an ``Ito`` is always *relative to itself*, not the basis string:

>>> str(i[0])    # int accessor
H
>>> str(i[-1])   # int accessor
!
>>> str(i[:5])   # slice accessor
Hello
>>> str(i[-6:])  # slice accessor
world!
  
While index access to the character data in a ``str`` returns another ``str``, index access to the character data in an ``Ito`` returns another ``Ito``:

>>> i[-6:]
Ito(Hello, world!', 7, 13, None)

Note that index access allows you to enumerate an ``Ito``:

>>> for idx, ito in enumerate(i[:5]):
...     print(idx, ito):
...
0: H
1: e
2: l
3: l
4: o

All index book keeping is handled internally, allowing code like this:

>>> j = i[-6:]   # new Ito based on the last 6 characters of Ito 'i'
>>> str(j[0:3])  # print first three characters of Ito 'j'

The idiom of relative access extends to the ``Ito`` constructor, which can take either a ``str`` or an ``Ito`` as the first parameter, ``src``.  The subsequent ``start`` and ``stop`` parameters are always *relative to ``src``*, with the original source string carried through and all indexing book-keeping handled automatically:

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # skip first an last chars o s
>>> i2 = Ito(i1, 1, -1)  # skip first and last chars of i1
>>> str(i1), str(i2)
('abc', 'b')

Descriptor
==========
``Ito`` features a ``.desc`` property that can be used to tag an ``Ito`` with an arbitrary string.  Values for ``.desc`` can be specified as the final constructor property, or post-instantition via a property of the same name::

 >>> i = Ito('abc', desc='something useful')
 >>> i.desc
 'something useful'
 >>> i.desc = 'something different'
 >>> i.desc
 'something different'
 
 The ``.desc`` property can be used to search and filter ``Ito`` collections.

 
 The low memory footprints offer a strong advantage for processing large strings because any substrings don't involve additional memory allocation.
 
Hierarchical Data Store
=======================

``Ito`` supports nested storage of child ``Ito`` instances via the ``.children`` property.  Nodes can be added in via the ``.add`` method in arbitrary order, and are stored in sorted order:

>>> s = 'ABC 123'
>>> root = Ito(s)
>>> root.children.add(root[-3:], root[:3])
>>> [str(c) for c in root.children]
['ABC', '123']

The ``.children`` collection is not an arbitrary data store.  Nodes added to it must meet the following criteria:

* An instance (or sublass) of ``Ito``
* Have the same reference ``str`` as the parent
* Not overlap any existing child nodes
* Be non-empty

As ``Ito`` objects, child nodes have their own ``.children` collections.  In other words, ``Ito`` is a hiearchical data store.  This quality  is used for many key features of ``ito-segments``"

* Storage and organization of substring data
* Traversal of substring collections
* Structured search and query

.. [#] Slices with step values other than 1 (or ``None``) are not supported because the resulting sequences of characters will typically *not* be valid substrings.  For example, ``'abc[::-1]`` results in the reversed string ``cba``, which doesn't align with the starting ``str``.
