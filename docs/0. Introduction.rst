============
Introduction
============

Jumping Right In : *What Pawpaw can do for you*
=================================================

Say you have some text::

>>> s = 'nine 9 ten 10 eleven 11 TWELVE 12 thirteen 13'

and you wish to perform an nlp-like segmentation on phrases, words, numbers, and so forth.  Given
the regular expression:

>>> re = regex.compile(r'(?P<phrase>(?P<word>(?P<char>\w)+) (?P<number>(?P<digit>\d)+)(?: |$))+')

You can use **pawpaw** as follows:

>>> doc = Ito(s)
>>> doc.children.add(*Ito.from_re(re, doc))

With just two lines of code, you now have a fully hierarchical, tree\ [#]_ of phrases, words, chars,
numbers, and digits.  This tree can be traversed, and even searched using a powerful XPATH-like
structured query language:

>>> print(*doc.find_all('**[d:digit]'), sep=', ')  # print all digits
9, 1, 0, 1, 1, 1, 2, 1, 3
>>> print(*doc.find_all('**[d:number]{</*[s:i]}'), sep=',')  # print numbers having leter 'i' in their names
9, 13

Dive a Bit Deeper: *Introducing* ``Ito``
========================================

>>> from pawpaw import Ito
>>> s = 'x Hello, world! x'
>>> i = Ito(s, 2, -2)
>>> print(i)
Hello, world!

The class 
>>> s = 'x Hello, world! x'
>>> i = Ito(s, 2, -2)
>>> print(i)
Hello, world!

The class ``Ito``, short for *In Text Object*, is a high performance, indexed substring. Creating
an ``Ito`` does *not* create a new string.  Rather, an ``Ito`` maintains a reference to a basis
string, along with start and stop indexes:

>>> i
Ito('Hello, world!', 2, 15, None)

Because ``Ito`` only maintains a reference to its basis string, its memory requirements are low:

>>> import sys
>>> sys.getsizeof(s), sys.getsizeof(i)
(66, 48)
>> s2 = s * 4096  # a big str
>>> sys.getsizeof(s2), sys.getsizeof(Ito(s2))
(69681, 48)

Index Access
============

Like a regular Python ``str``, you access the character data in an ``Ito`` via ``int`` or ``slice`` indexers\ [#]_\ .  Indexing an ``Ito`` is always *relative to itself*, not the basis string:

>>> str(i[0])    # int accessor
H
>>> str(i[-1])   # int accessor
!
>>> str(i[:5])   # slice accessor
Hello
>>> str(i[-6:])  # slice accessor
world!
  
While index access to the character data in a ``str`` returns another ``str``, index access to the character data in an ``Ito`` returns another ``Ito``:

>>> i[-6:]
Ito(Hello, world!', 7, 13, None)

Note that index access allows you to enumerate an ``Ito``:

>>> for idx, ito in enumerate(i[:5]):
...     print(idx, ito):
...
0: H
1: e
2: l
3: l
4: o

All index book keeping is handled internally, allowing code like this:

>>> j = i[-6:]   # new Ito based on the last 6 characters of Ito 'i'
>>> str(j[0:3])  # print first three characters of Ito 'j'

The idiom of relative access extends to the ``Ito`` constructor, which can take either a ``str`` or an ``Ito`` as the first parameter, ``src``.  The subsequent ``start`` and ``stop`` parameters are always *relative to ``src``*, with the original source string carried through and all indexing book-keeping handled automatically:

>>> s = '_abc_'
>>> i1 = Ito(s, 1, -1)   # skip first an last chars o s
>>> i2 = Ito(i1, 1, -1)  # skip first and last chars of i1
>>> str(i1), str(i2)
('abc', 'b')

Descriptor
==========
``Ito`` features a ``.desc`` property that can be used to tag an ``Ito`` with an arbitrary string.  Values for ``.desc`` can be specified as the final constructor property, or post-instantition via a property of the same name::

 >>> i = Ito('abc', desc='something useful')
 >>> i.desc
 'something useful'
 >>> i.desc = 'something different'
 >>> i.desc
 'something different'
 
 The ``.desc`` property can be used to search and filter ``Ito`` collections.

 
 The low memory footprints offer a strong advantage for processing large strings because any substrings don't involve additional memory allocation.
 
Tree Data Store
===============

``Ito`` supports nested storage of child ``Ito`` instances via the ``.children`` property.  Nodes can be added in via the ``.add`` method in arbitrary order, and are stored in sorted order:

>>> s = 'ABC 123'
>>> root = Ito(s)
>>> root.children.add(root[-3:], root[:3])
>>> [str(c) for c in root.children]
['ABC', '123']

The ``.children`` collection is not an arbitrary data store.  Nodes added to it must meet the following criteria:

* An instance (or sublass) of ``Ito``
* Have the same reference ``str`` as the parent
* Not overlap any existing child nodes
* Be non-empty

As ``Ito`` objects, child nodes have their own ``.children` collections.  In other words, ``Ito`` and its descednants are hieraarchical, and from a tree graph.  a hiearchical data store.  This quality  is used for many key features of ``pawpaw``"

* Storage and organization of substring data
* Traversal of substring collections
* Structured search and query

Aborform
========

Pawpaw makes it easy to create to create trees.  As seen in the introduction above, a fully formed tree of arbitrary depth can be formed using a regular expression.  However, creating every larger regular expressions can be unwieldy.  The ``.aborform`` namespace contains a large number of tools to help you quicly build trees.  For example, the earlier example can also be created in piecemeal fashion follows::

>>> s = 'nine 9 ten 10 eleven 11 TWELVE 12 thirteen 13'
>>>
>>> to_phrases = Split(regex.compile('(?<=\d )'), desc='Phrase')
>>>
>>> to_wrd_nums = Split(regex.compile('\s'))
>>> to_phrases.itor_children = to_wrd_nums
>>>
>>> wrd_num_desc = Desc(lambda ito: 'number' if ito.str_isdecimal() else 'word')
>>> to_wrd_nums.itor_next = wrd_num_desc
>>>
>>> to_chr_dig = Extract(regex.compile(r'(?P<c>.)'))
>>> wrd_num_desc.itor_children = to_chr_dig
>>>
>>> chr_dig_desc = Desc(lambda ito: 'digit' if ito.str_isdecimal() else 'char')
>>> to_chr_dig.itor_next = chr_dig_desc
>>>
>>> root = Ito(s)
>>> root.children.add(*to_phrases.traverse(root))

.. [#] A tree is an undirected graph in which any two vertices are connected by exactly one path.  An ``Ito`` is technically a *rooted tree*, where the root is the ``Ito`` and the branches and leaves its descendants.

.. [#] Slices with step values other than 1 (or ``None``) are not supported because the resulting sequences of characters will typically *not* be valid substrings.  For example, ``'abc[::-1]`` results in the reversed string ``cba``, which doesn't align with the starting ``str``.

