# Traversal & Query

## Introduction

Pawpaw's ``Ito`` class features recursive storage of descendants to arbitrary depth, resulting in a fully hierarchical data store.  The resulting trees
can be searched for relevant data using either manual traversal techniques, or a highly capable structured query syntax called *plumule*[^plumule].

### Manual Traversal

Manually traversing Pawpaw trees is possible using either the ``.children`` property to access an ``Ito`` object's children, or the ``.parent`` property to access the its parent:

```python
>>> from pawpaw import Ito
>>> s = 'the quick brown fox'
>>> re = regex.compile(r'(?P<word>(?P<char>\w)+\W*)*')
>>> i = Ito.from_match(re.fullmatch(s))
>>> last_child = i.children[-1]  # traverse down to child
>>> str(last_child)  
'fox'
>>> str(last_child.parent)  # traverse up to parent
'the quick brown fox'
```

In addition to the ``.parent`` and ``.children``, three methods are available to facilitate traversal:

| Method                       | Description |
| :---                         | :--- |
| ``.get_root``                | Finds root of current node; returns None if the current node is itself a root |
| ``.walk_descendants``        | Performs a depth-first traversal of all descendants of current node |
| ``.walk_descendants_levels`` | Performs a depth-first traversal of all descendants of current node, yielding a ``Tuple[int, Ito]`` for each node whose integer is the depth from the starting node |

Example:

```python
>>> print('|'.join(str(d) for d in i.walk_descendants()))
the|t|h|e|quick|q|u|i|c|k|brown|b|r|o|w|n|fox|f|o|x
```

## Plumule Queries

Manually traversing Pawpaw trees is practical for small collections.  Larger collections,
by contrast, can benefit from Pawpaw *plumule* queries.  Plumule is similar in syntax to
`XPath <https://www.w3.org/TR/xpath/>` in syntax and usage.  For example:

```python
>>> plumule_xpr = '*{*[s:o]}'  # words containing char 'o'
>>> print([str(w) for w in i.find_all(plumule_xpr)])
['brown', 'fox']
```

Because Plumule queries are strings, they can be persisted and used against multiple trees.  Plumule
queries are interpreted by the Pawpaw *radicle* query engine, which even allows you to pre-compile
them for faster performance:

```python
>>> query = pawpaw.query.compile(plumule_xpr)
>>> print([str(w) for w in query.find_all(i)])
['brown', 'fox']
```

### Plumule Syntax

A Plumule query allows you to query for arbitrary nodes in an ``Ito`` Tree.  A query consists
of one or more *phrases* separated by fore-slash characters:

```
query := phrase [/ phrase] [/ phrase] ...
```

### Phrases

A phrase consists of an *axis* along with an optional *filters* and *subqueries* parts:

```
phrase := axis [filters] [subqueries]
```

### Axis

An axis consists of an optional *order operator*, a required *axis identifier*, and an optional *self option*:

```
axis := [order_operator] axis_identifier [self_option]
```

A Plumule axis defines a traversal step.  For example, the axis identifier ``*`` indicates that traversal
should proceed to the children of the current node(s).  For a given node, an axis may yield zero,
one, or more nodes, the default order of which will always be from nearest to farthest from the current node.

The order of nodes can be reversed by using a minus character (-) for the order operator.  A plus
character (+) indicates nearest-to-furthest ordering, and is the assumed default when the
order operator is not supplied.

In some cases, it may be useful to return the current node as part traversal step.  For example,
the axis operator ``..`` indicates traversal to the parent node, however, if the current node is
a root, then there is no parent to traverse to.  The self option can be used to ensure that a
traversal step will always return something.  Two possible values are allows:

#### Self Option Values

| Value  | Returns Current Node If |
| :---:  | :--- |
| ``!``  | Traversal step is empty |
| ``!!`` | Always |

If a self option is supplied, the current node will always be returned first, unless
the axis is reversed with the '-' operator.

#### Axis Identifiers

|  Identifier  |     Meaning    | Description |
| :---         | :---           | :--- |
| ``....``     | root           | Furthest ancestor of the current node that has no ancestors itself  |
| ``...``      | ancestors      | All ancestors of the current node beginning with the parent and ending with the root |
| ``..``       | parent         | Nearest ancestor of the current node |
| ``.``        | self           | Reflection of the current node |
| ``*``        | children       | Children of the current node |
| ``**``       | descendants    | All descendants of the current node, starting with the children and ending with leaves |
| ``***``      | leaves         | Descendants of the current node that have no descendants themselves |
| ``<<<``      | preceeding     | Nodes that are *before* the current node, *includes* prior siblings and *excludes* ancestors & descendants |
| ``<<``       | prior siblings | Nodes *before* the current node that have the same parent |
| ``<``        | prior sibling  | The nearest node *before* the current node that has the same parent |
| ``>``        | next sibling   |  The nearest node *after* the current node that has the same parent |
| ``>>``       | next siblings  |  Nodes *after* the current node that have the same parent |
| ``>>>``      | following      | Nodes that are *after* the current node, *includes* prior siblings and *excludes* ancestors & descendants |

#### Examples

```python
 '*'    # all children; equivalent to iter(i.children)
 '*/*'  # all grandchildren; equivalent to iter(gc for c in i.children for gc in c.children)
 '../*' # all siblings and self: equivalent to i.parent.children
 '>>/*' # children of all successive siblings
```

### Filters

A phrase filters expression defines what A filter only allows nodes matching a given criteria to pass through,
and conists of one or more *filter* expressions separated by logical operators.  Parentheses may be used
to group filter expressions when you need to override the default operator precedance:

```
filters := [not_operator] filter [ combining_operator [not_operator] filter ]...
````

#### Operators

The not operator consists of the tilde character ('~'):

```
not_operator := '~'
```

A combining operator consists of either a '&', '^', or '|' character:

```
combining_operator := '&, '^', or '|'
```
 
The operators are listed below in order of precedence:

|  Operator  |  Combining  |  Meaning  |
| :---:      | :---:       | :---:     |
| ``~``     |              | NOT       |
| ``&``     | ✓            | AND       |
| ``^``     | ✓            | XOR       |
| ``|``     | ✓            | OR        |

#### Filter

A filter consists key-value pair, surrounded by square brackets.  You can prefix a key with the not operator ('~'), which has the same effect as if it occurs immediately to the left of the opening bracket.

 ```
 filter := '[' [NOT] key ':' value ']'
 ```

The filter key conists of a string that indicates what filtering action to perform on the current axis nodes.  The filter value
provides additional data to the filtering action.  Allowable values for keys and values are as follows:

| Key                   | Alt Keys(s) | Meaning                                                                 | Example(s)                             |
| :----:                | :----:      | :---                                                                    | :---                                   |
| ``'desc'``            | ``'d'``     | One or more ``str`` values used to match againss ``.desc`` of axis; values must be separated with commas, literal commas must be escaped | ``[d:number]``<br />``[d:word,char]`` |
| ``'string'``          | ``'s'``     | A ``str`` used to match against ``.__str__()`` of axis | ``[s:foo]``<br />``[s:foo,goo]``|
| ``'string-casefold'`` | ``'scf'``,<br />``'lcs'`` | Like ``s``, with ``.casefold()`` applied to supplied value *and* value *and* ``.__str__()`` of axis prior to compare | ``[scf:FoO,GoO]`` |
| ``'index'``           | ``'v'``     | One or more tuples consisting of a *start* and optional *stop* ``int`` values used to match against the enumeration index(ices) of the axis; *start* and *stop* must be separated with hyphens, tuples must be separated with commas | ``[i:1]``<br />``[i:2,3,4]``<br />``[i:2-3]``<br />``[i:2,5-7]`` |
| ``'predicate'``       | ``'p'``     | Key for filter function used to match against axis A ``str`` used as a key to entry in dictionary of type:     typing.Dict[str, typing.Callable[[int, Ito], bool]  The value retrieved from the ``dict`` use used as a filter against the axis | ``[p:key1]``<br />``[p:key1,key2]`` |
| ``'value'``           | ``'v'``      | A ``str`` used as a key to entry in dictionary of type::      typing.Dict[str, typing.Any]  The value retrieved from the ``dict`` is used to match against the ``.value()`` of the axis | ``[p:key]``<br />``[p:key1, key2]`` |

Parentheses are allowed to perform logical grouping:

#### Examples

```python
 '*[d:word,number]'  # all children having .desc equal to 'word' or 'number'
 '**[~d:word] | ([d:word] & [s:ten])'  # all descedndants with .desc not 'word', or with .desc 'word and .__str__() 'ten'
```

## TIPS & TRICKS

Q: How can I 'OR' together a filter and subquery?

A: Operators are not supported between the filter and subquery components of a query phrase.  However, you can achieve the same result by moving the filter to a subquery::

```
[my_filter]{my_subquery}  ->  {./[my_filter]} | {my_subquery}
```

[^plumule]: **plumule**: the rudimentary shoot or stem of an embryo plant
